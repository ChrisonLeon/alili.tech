<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Daily on Hello Alili</title>
    <link>https://alili.tech/tags/daily/</link>
    <description>Recent content in Daily on Hello Alili</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Fri, 18 Sep 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://alili.tech/tags/daily/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>TensorFlow中的Tensor是什么?</title>
      <link>https://alili.tech/archive/97enyq3a3m/</link>
      <pubDate>Fri, 18 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://alili.tech/archive/97enyq3a3m/</guid>
      <description>Tensor(张量) “张量”一词最初由威廉·罗恩·哈密顿在1846年引入。对，就是那个发明四元数的哈密顿：
 Tensor实际上就是一个多维数组（multidimensional array）
 Tensor的目的是能够创造更高维度的矩阵、向量。
  色彩的例子 彩色图像文件（RGB）一般都会处理成3-d tensor，每个2d array中的element表示一个像素，R代表Red，G代表Green，B代表Blue
多维数组 把三维张量画成一个立方体：
更高维的张量:
初始化一个向量 0维 tf.tensor(1).print();  1维 tf.tensor([1, 2, 3, 4]).print(); // or tf.tensor1d([1, 2, 3]).print();  2维 tf.tensor([[1, 2], [3, 4]]).print(); // or tf.tensor2d([[1, 2], [3, 4]]).print();  3维 tf.tensor([[[1], [2]], [[3], [4]]]).print(); // or tf.tensor3d([[[1], [2]], [[3], [4]]]).print();  4维 tf.tensor([[[[1], [2]], [[3], [4]]]]).print(); // or tf.tensor4d([[[[1], [2]], [[3], [4]]]]).print();  5维 tf.tensor([[[[[1], [2]], [[3], [4]]]]]).</description>
    </item>
    
    <item>
      <title>数学篇 - 数据结构丶编程语句丶基础算法与数学的关系(笔记)</title>
      <link>https://alili.tech/archive/97enyq3a3m/</link>
      <pubDate>Tue, 15 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://alili.tech/archive/97enyq3a3m/</guid>
      <description>看到很多人说,数据结构,算法不能算作数学.
 不同的数据结构，都是在编程中运用数学思维的产物。 每种数据结构都有自身的特点，有利于我们更方便地实现某种特定的数学模型.
 数据结构  别小看这些数据结构，它们其实就是一个个解决问题的“模型”
 数组 (Array) 特点: 可以通过下标，直接定位到所需的数据,适合随机访问.常常和循环语句相结合，来实现迭代法，例如二分查找、斐波那契数列等等
缺点: 数组只对稠密的数列更有效。如果数列非常稀疏，那么很多数组的元素就是无效值，浪费了存储空间。此外，数组中元素的插入和删除也比较麻烦，需要进行数据的批量移动。
如何解决稀疏数列问题: 链表
链表 (Linked List) 链表中的结点存储了数据，而链表结点之间的相连关系，在 JavaScript 语言中是通过对象引用来实现的。
特点: 不能通过下标来直接访问数据，而是必须按照存储的结构逐个读取
优势: 不必事先规定数据的数量，也不再需要保存无效的值，表示稀疏的数列时可以更有效的利用存储空间，同时也利于数据的动态插入和删除
缺点: 于数组而言，链表无法支持快速地随机访问，进行读写操作时就更耗时
哈希表 (Hash) 哈希表就可以通过数组和链表来构造,之前我们通过余数来实现哈希表.
优势：如果关键字已知则存取速度极快，插入块
缺点：删除慢，如果不知道关键则存取很慢，对存储空间使用不充分,会出现哈希冲突
树 (Tree) 优点：查找，插入，删除都快，树总是平衡的。类似的树对磁盘存储有用,不会出现哈希冲突
缺点：算法复杂
图(Graph) 图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系
栈 ( Stack) 先进后出的。在我们进行函数递归的时候，函数调用和返回的顺序，也是先进后出，所以，栈体现了递归的思想，可以实现基于递归的编程
队列 (Queue) 先进先出的数据结构，先进入队列的元素会优先得到处理.
在消息队列中,实现了生产者和消费者的松耦合，对消费者起到了保护作用，使它不容易被数据洪流冲垮。
编程语句 布尔表达式 体现了逻辑代数中逻辑和集合的概念
if(表达式) {函数体1} else {函数体2} // 若表达式为真，执行函数体1，否则执行函数体2。  循环语句 循环语句是迭代法（Newton&#39;s method）的体现
函数的调用 可以调用自己，也可以调用其他不同的函数。如果不断地调用自己，这就体现了递归的思想。
SQL 语言中的 Join 操作 Join 有多种类型，每种类型其实都对应了一种集合的操作。</description>
    </item>
    
    <item>
      <title>数学篇 - 朴素贝叶斯(Naive Bayes)分类算法(笔记)</title>
      <link>https://alili.tech/archive/6iwpimvelxh/</link>
      <pubDate>Mon, 14 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://alili.tech/archive/6iwpimvelxh/</guid>
      <description>朴素贝叶斯(Naive Bayes)  “用客观的新信息更新我们最初关于某个事物的信念后，我们就会得到一个新的、改进了的信念。” &amp;mdash;- 数学家托马斯·贝叶斯(Thomas Bayes，1702～1761)
 当你不能准确知悉一个事物的本质时，你可以依靠与事物特定本质相关的事件出现的多少去判断其本质属性的概率。
支持某项属性的事件发生得愈多，则该属性成立的可能性就愈大。
1774年，法国数学家皮埃尔-西蒙·拉普拉斯(Pierre-Simon Laplace，1749-1827)独立地再次发现了贝叶斯公式。
换种写法:
让计算机分辨水果 我们需要将水果的特征转化为计算机所能理解的数据。最常用的方式就是提取现实世界中的对象之属性，并将这些转化为数字。
比如：形状、外皮颜色、斑马纹理、重量、握感、口感。
将这些形容转化成数字,把重量由连续值转化成了离散值，这是因为朴素贝叶斯处理的都是离散值
扩大样本,仅仅 3 个水果还不足以构成朴素贝叶斯分类所需的训练样本
我们如何使用贝叶斯公式  用先验概率和条件概率估计后验概率。
 假定数据对象的不同属性对其归类影响时是相互独立的。此时若数据对象 o 中同时出现属性 fi 与 fj，则对象 o 属于类别 c 的概率就是这样
 朴素贝叶斯算法是假设各个特征之间相互独立,才可以两边相等,这也是朴素贝叶斯分类有朴素一词的来源
 用 10 个水果的数据，来建立朴素贝叶斯模型
平滑（Smoothing） 会出现结果为 0 的情况，因此我们通常取一个比这个数据集里最小统计概率还要小的极小值，来代替“零概率”。比如，我们这里取 0.01。在填充训练数据中从来没有出现过的属性值的时候，我们就会使用这种技巧，我们给这种技巧起个名字就叫作平滑（Smoothing）。
例题: 假设我们有一个新的水果，它的形状是圆形，口感是甜的，那么根据朴素贝叶斯，它属于苹果、甜橙和西瓜的概率分别是多少呢？
apple 表示分类为苹果，shape-2 表示形状属性的值为 2（也就是圆形），taste-2 表示口感属性的值为 2。以此类推，我们还可计算该水果属于甜橙和西瓜的概率。
比较这三个数值，0.00198&amp;lt;0.00798&amp;lt;0.26934，所以计算机可以得出的结论，该水果属于甜橙的可能性是最大的
朴素贝叶斯分类主要包括这几个步骤  准备数据：针对水果分类这个案例，我们收集了若干水果的实例，并从水果的常见属性入手，将其转化为计算机所能理解的数据。这种数据也被称为训练样本。
 建立模型：通过手头上水果的实例，我们让计算机统计每种水果、属性出现的先验概率，以及在某个水果分类下某种属性出现的条件概率。这个过程也被称为基于样本的训练。
 分类新数据：对于一颗新水果的属性数据，计算机根据已经建立的模型进行推导计算，得到该水果属于每个分类的概率，实现了分类的目的。这个过程也被称为预测。
  朴素贝叶斯分类的优缺点  优点：
 算法逻辑简单,易于实现
 分类过程中时空开销小</description>
    </item>
    
    <item>
      <title>数学篇 - 概率之联合概率、条件概率、边缘概率和贝叶斯法则(笔记)</title>
      <link>https://alili.tech/archive/haz1cu03hf/</link>
      <pubDate>Sun, 13 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://alili.tech/archive/haz1cu03hf/</guid>
      <description>公式符号解释: P(A|B).是B已知下的A的条件概率
 联合概率（Joint Probability） 各种解释描述,便于理解:
 联合概率指的是包含多个条件且所有条件同时成立的概率，记作P(X=a,Y=b)或P(a,b)，有的书上也习惯记作P(ab)，但是这种记法个人不太习惯，所以下文采用以逗号分隔的记法。一定要注意是所有条件同时成立！
 两个以上事件的交集的概率
   例子：从一副扑克牌中抽出一张红色的4的概率为P(红4) = 2&amp;frasl;52 = 1/26。（一副扑克牌有52张牌，想抽到的是红心4和方块4）。
 条件概率（Conditional Probability）  条件概率是已知某（些）事件已经发生的前提下，另一（些）事件发生的概率。已知事件B已经发生时，事件A发生的条件概率写作P(A|B)。
 条件概率表示在条件Y=b成立的情况下，X=a的概率，记作P(X=a|Y=b)或P(a|b)，
   例子：已知我们抽到了一张红色的牌，这张牌是4的概率为P(4|红) = 2&amp;frasl;26 = 1&amp;frasl;13 （一副扑克牌有52张牌，26张红色的，26张黑色的。现在因为我们已经抽到了一张红色的牌，我们知道我们抽取的范围是26张牌，因此第一个除数是26）。
 联合概率与条件概率的区别 解释1: P(AB) 联合概率：池子没变。
P(A|B) 条件概率：池子变小了！！！！！！
所以如果用条件概率来算联合概率的话：池子不能小，给我乘回去！！！！
P(A|B) x P(B) = P(AB)
解释2: 当我们想要知道抽到一张红色的4的扑克牌的概率（红色和4的联合概率）时，我想让你想象一下，把所有52张牌面朝下放置，然后随机选中一张。在这52张牌中，有2张是红色的，同时数字是4（红心4和方块4）。所以联合概率是2/52 = 1/26。
而当我们想要知道已知抽中的牌是红色的时候，抽中数字是4的牌的概率，即条件概率P(4|红)时，我想让你再想象一下有52张牌。不过，在随机抽取一张牌之前，你给所有扑克牌排了个序，选中了所有26张红色的牌。现在你把这26张牌面朝下放置，然后随机选择一张牌。同样，这些红色的牌中有两张数字为4，所以条件概率是2/26 = 1&amp;frasl;13
公式描述 边缘概率 解释:
 对于离散型随机变量，我们可以通过通过联合概率 P(x, y) 在 y 上求和，就可以得到 P(x)。对于连续型随机变量，我们可以通过联合概率 P(x, y) 在 y 上的积分(无限求和)，推导出概率 P(x)。这个时候，我们称 P(x) 为边缘概率。</description>
    </item>
    
    <item>
      <title>数学篇 - 概率之随机变量与分布(笔记)</title>
      <link>https://alili.tech/archive/6mchh1x7mrv/</link>
      <pubDate>Sat, 12 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://alili.tech/archive/6mchh1x7mrv/</guid>
      <description>随机变量（ random variable )  设随机试验的样本空间为S SS，X = X ( e ) X=X(e)X=X(e)是定义在样本空间S SS上的实值单值函数。称X = X ( e ) X=X(e)X=X(e)为随机变量。 本质是关于基本事件的函数，自变量是基本事件，因变量是函数值。  随机试验： 满足:
 (1)可重复性:试验在相同条件下可重复进行；
 (2)可知性:每次试验的可能结果不止一个，并且事先能明确试验所有可能的结果；
 (3)不确定性:进行一次试验之前不能确定哪一个结果会出现，但必然会出现结果中的一个。
  样本空间： 随机试验的所有基本结果组成的集合称为样本空间。样本空间的元素称为样本点或基本事件。即样本空间本质是一个集合，每一个元素都是一次随机试验的结果。
样本和随机变量: 数理统计里的样本具有二重性，即样本既可以看作是一组观测值又可以看作是随机变量。
 第一，在抽样之前。无法确定样本的观测值，所以可以看成是随机变量。
 第二，样本在抽取以后，经观测，样本抽有了具体的观测值，故又可以看成是一组确定的值。
  概率分布 我们拿最简单的抛硬币事件来看。从理论上说来，出现正面和反面的概率都是 50%
使用代码来尝试 function flipCoin(){ for (let index = 0; index &amp;lt; 10; index++) { // 对随机数四舍五入 let randomNum = Math.round(Math.random()) // 随机为1则为正面 if(randomNum === 1){ console.</description>
    </item>
    
    <item>
      <title>数学篇 - 树的深度优先搜索与广度优先搜索(笔记)</title>
      <link>https://alili.tech/archive/5g1oligl91/</link>
      <pubDate>Fri, 11 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://alili.tech/archive/5g1oligl91/</guid>
      <description>如何使用递归和栈实现深度优先搜索？ 深度优先搜索的过程和递归调用在逻辑上是一致的。
写一个 TreeNode类代码,支持插入节点 class TreeNode { constructor(key){ this.key = key; this.sons = [] } insert(key){ let node = new TreeNode(key); this.sons.push(node) return node } } }  尝试创建一棵树 let str = &#39;hello word&#39; let str2 = &#39;abcdefg&#39; // 根节点 let root = new TreeNode(&amp;quot;root&amp;quot;) createTree(str,root) createTree(str2,root) function createTree(strs,parent){ if(strs.length !==0){ let found = parent.sons.find((item)=&amp;gt;item.key === strs[0]) if(found){ let newStrs = strs.slice(1) createTree(newStrs,parent) }else{ let node = parent.insert(strs[0]) let newStrs = strs.</description>
    </item>
    
    <item>
      <title>数学篇 - 树的概念(笔记)</title>
      <link>https://alili.tech/archive/rakfaq9whbo/</link>
      <pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://alili.tech/archive/rakfaq9whbo/</guid>
      <description> 树的基本概念 树是由结点或顶点和边组成的(可能是非线性的)且不存在着任何环的一种数据结构。没有结点的树称为空(null或empty)树。一棵非空的树包括一个根结点，还(很可能)有多个附加结点，所有结点构成一个多级分层结构。
 树是一种特殊的图 (后续文章会提到图).
 前缀树 prefix tree (字典树 - trie) 有向树 它的边是有方向的。而树是没有简单回路的连通图。
以结点 v 为出发点的边的数量，我们叫作 v 的出度。而以 v为 终点的边之数量，称为 v 的入度。在上图中，结点 v2​ 的入度是 1，出度是 2。
回路和连通 高度与结点 二叉树 二叉树又分为：完美二叉树，完全二叉树，完满二叉树
完美二叉树(满二叉树) 除了叶子节点之外的每一个节点都有两个子节点,每一层(包括最后一层)都被完全填充 完全二叉树 完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐 完满二叉树 所有非叶子结点的度都是2 换句话说：只要你有孩子，你就必然是有两个孩子。 </description>
    </item>
    
    <item>
      <title>数学篇 - 动态规划,编辑距离的计算(笔记)</title>
      <link>https://alili.tech/archive/nfo3tlig7y/</link>
      <pubDate>Wed, 09 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://alili.tech/archive/nfo3tlig7y/</guid>
      <description>动态规划 （Dynamic Programming） 很多人也简称DP,动态规划需要通过子问题的最优解，推导出最终问题的最优解，因此这种方法特别注重子问题之间的转移关系。我们通常把这些子问题之间的转移称为状态转移，并把用于刻画这些状态转移的表达式称为状态转移方程。
编辑距离 (莱文斯坦距离,又称Levenshtein距离) 俄罗斯科学家弗拉基米尔·莱文斯坦（毕业于莫斯科国立大学数学和力学系）在1965年提出，他因对纠错码理论和信息理论的贡献，于2006年获得IEEE Richard W. Hamming奖章。
 定义：莱文斯坦距离也称编辑距离，指的是将文本 A 编辑成文本 B 需要的最少变动次数（每次只能增加、删除或修改一个字）。
 用途：可以用来计算字符串的相似度，文本相似度, 拼写纠错和抄袭侦测等等
 优点：准确率很高，编辑距离算出来很小，文本相似度肯定很高。
 缺点：召回率不高，由于编辑距离与文本的顺序有关。在文字相同，文字顺序变化很大的情况下，相似度会变得很低。比如“正大光明”和“光明正大”其实是一个意思。但编辑距离是4，完全不匹配
  计算解析： 首先定义的单字符编辑操作有且仅有三种：
插入（Insertion）
删除（Deletion）
替换（Substitution）
搜索推荐关键词的应用 计算 mouuse 与 mouse的编辑距离
表格推导  这里面求最小值的 min 函数里有三个参数，分别对应三种情况的编辑距离，分别是：替换、插入和删除字符。
 代码实现 /** * @Description: 使用状态转移方程，计算两个字符串之间的编辑距离 * @param a-第一个字符串，b-第二个字符串 * @return let-两者之间的编辑距离 */ function getStrDistance( a, b) { if (a == null || b == null) return -1; // 初始用于记录化状态转移的二维表 let d = [] for (let index = 0; index &amp;lt;= a.</description>
    </item>
    
    <item>
      <title>数学篇 - 组合,解决赛程规划与自然语言处理(笔记)</title>
      <link>https://alili.tech/archive/yraotmb3ot/</link>
      <pubDate>Tue, 08 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://alili.tech/archive/yraotmb3ot/</guid>
      <description>组合 组合（combination）是一个数学名词。一般地，从n个不同的元素中，任取m（m≤n）个元素为一组，叫作从n个不同元素中取出m个元素的一个组合。我们把有关求组合的个数的问题叫作组合问题。
对于所有 m 取值的组合之全集合，我们可以叫作全组合（All Combination）。例如对于集合{1, 2, 3}而言，全组合就是{空集, {1}, {2}, {3}, {1, 2}, {1,3} {2, 3}, {1, 2, 3}}。
如何安排世界杯赛程 想让全部的 32 支球队都和其他球队进行一次主客场的比赛.
自己不可能和自己比赛，不可重复的排列中，主场球队有 32 种选择，而客场球队有 31 种选择。那么一共要进行多少场比赛呢？很简单，就是 32x31=992 场！
在实际情况中,赛程设计并没有这样做.
这就是为什么要将所有 32 支队伍分成 8 个小组先进行小组赛的原因。一旦分成小组，每个小组的赛事就是 (4x3)/2=6 场。所有小组赛就是 6x8=48 场。
加上在 16 强阶段开始采取淘汰制，两两淘汰，所以需要 8+4+2+2=16 场淘汰赛（最后一次加 2 是因为还有 3、4 名的决赛），那么整个世界杯决赛阶段就是 48+16=64 场比赛。
这两两配对比赛的场次，我是如何计算出来的？让我引出今天的概念，组合（Combination）。
让计算机来组合队伍 /* * @Description: 使用函数的递归（嵌套）调用，找出所有可能的队伍组合 * @param teams-目前还剩多少队伍没有参与组合，result-保存当前已经组合的队伍 * @return void */ let teams = [&amp;quot;t1&amp;quot;, &amp;quot;t2&amp;quot;, &amp;quot;t3&amp;quot;]; combine(teams,[],2) function combine(teams,result,m) { // 挑选完了m个元素，输出结果 if (result.</description>
    </item>
    
    <item>
      <title>数学篇 - 排列,解决田忌赛马与密码爆破问题(笔记)</title>
      <link>https://alili.tech/archive/9kfvaensryf/</link>
      <pubDate>Mon, 07 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://alili.tech/archive/9kfvaensryf/</guid>
      <description>田忌赛马的故事 田忌是齐国有名的将领，他常常和齐王赛马，可是总是败下阵来，心中非常不悦。孙膑想帮田忌一把。他把这些马分为上、中、下三等。他让田忌用自己的下等马来应战齐王的上等马，用上等马应战齐王的中等马，用中等马应战齐王的下等马。三场比赛结束后，田忌只输了第一场，赢了后面两场，最终赢得与齐王的整场比赛。
排列概念 从 n 个不同的元素中取出 m（1≤m≤n）个不同的元素，按照一定的顺序排成一列，这个过程就叫排列（Permutation）。
当 m=n 这种特殊情况出现的时候,这就是全排列（All Permutation）
田忌赛马的排列图 最终排列的数量 排列总数的计算 3x2x1=6
 对于 n 个元素的全排列，所有可能的排列数量就是 nx(n-1)x(n-2)x…x2x1，也就是 n!
 对于 n 个元素里取出m (0&amp;lt;m≤n) 个元素的不重复排列数量是 nx(n-1)x(n-2)x…x(n - m + 1)，也就是 n!/(n-m)!
  使用代码计算田忌赛马的各种情况 // 齐王的马与速度 let q_horses_time = { q1: 1, q2: 2, q3: 3 } // 田忌的马与速度 let t_horses_time = { t1: 1.5, t2: 2.5, t3: 3.5 } // 他们马的名字 let q_horses = [&amp;quot;q1&amp;quot;, &amp;quot;q2&amp;quot;, &amp;quot;q3&amp;quot;] let t_horses = [&amp;quot;t1&amp;quot;, &amp;quot;t2&amp;quot;, &amp;quot;t3&amp;quot;] /** * @Description: 使用函数的递归（嵌套）调用，找出所有可能的马匹出战顺序 * @param horses-目前还剩多少马没有出战，result-保存当前已经出战的马匹及顺序 * @return void */ function permutate(horses, result) { // 所有马匹都已经出战，判断哪方获胜，输出结果 if (horses.</description>
    </item>
    
    <item>
      <title>数学篇 - 递归,分而治之，从归并排序到MapReduce(笔记)</title>
      <link>https://alili.tech/archive/zr4ve5abfzg/</link>
      <pubDate>Sun, 06 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://alili.tech/archive/zr4ve5abfzg/</guid>
      <description>黄申老师的标题实在是太好了,找不到更好的标题来描述今天学习的内容.啊哈哈~
归并排序中的分治思想  问题: 对一堆杂乱无序的数字，按照从小到大或者从大到小的规则进行排序
 有序情况 尝试合并有序数组{1, 2, 5, 8}和{3, 4, 6}的过程。 乱序情况 尝试把问题不断简化，也就是把数列不断简化，一直简化到只剩 1 个数。1 个数本身就是有序的，
把将长度为 n 的数列，每次简化为长度为 n-1 的数列，直至长度为 1。不过，这样的处理没有并行性，要进行 n-1 次的归并操作，但是效率会很低.
引入分而治之（Divide and Conquer）的思想 分而治之，我们通常简称为分治。它的思想就是，将一个复杂的问题，分解成两个甚至多个规模相同或类似的子问题，然后对这些子问题再进一步细分，直到最后的子问题变得很简单，很容易就能被求解出来，这样这个复杂的问题就求解出来了。
一个数组的排序 两个数组排序后合并
最重要的思想在于如何拆解问题 归并排序的不同阶段
使用递归的方式来实现已上思路 // 递归拆分数组 function merge_sort(to_sort) { // 非法数据,直接返回[] if (!to_sort) return []; // 如果分解到只剩一个数，返回该数 if (to_sort.length == 1) return to_sort; // 将数组分解成左右两半 let mid = to_sort.length / 2; // js中的splice会操作原数组内容, // 前半段取出来之后,后半段直接取原数组的变量应用就好了 let left = [].</description>
    </item>
    
    <item>
      <title>数学篇 - 递归,复杂问题分解(笔记)</title>
      <link>https://alili.tech/archive/ru7lce72gge/</link>
      <pubDate>Sat, 05 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://alili.tech/archive/ru7lce72gge/</guid>
      <description>递归与循环 理论上所有递归能做到的循环都能实现.
递归和循环其实都是迭代法的实现，而且在某些场合下，它们的实现是可以相互转化的。
为什么要使用递归  既然递归的函数值返回过程和基于循环的迭代法一致，我们直接用迭代法不就好了，为什么还要用递归的数学思想和编程方法呢？
 如何在限定总和的情况下，求所有可能的加和方式？  假设有四种面额的钱币，1 元、2 元、5 元和 10 元，要奖励别人10元，那可以奖赏 1 张 10 元，或者 10 张 1 元，或者 5 张 1 元外加 1 张 5 元等等。最终会有多少种方案?
 如何把复杂的问题简单化？ // 面额 var rewards = [1, 2, 5, 10]; /** * @Description: 使用函数的递归（嵌套）调用，找出所有可能的奖赏组合 * @param totalReward-奖赏总金额，result-保存当前的解 * @return void */ function get(totalReward,result){ // 如果所有奖励全部给完 if (totalReward == 0) { // 拿到复合条件的结果,输出 console.log(result); return; } // 如果奖励的钱超过当初设想的奖励(钱给多了), // 则不是我们想要的结果 if (totalReward &amp;lt; 0) { return; } //根据不同面额触发,让他们开始递归 for (let i = 0; i &amp;lt; rewards.</description>
    </item>
    
    <item>
      <title>数学篇 - 数学归纳法,给计算机注入灵魂(笔记)</title>
      <link>https://alili.tech/archive/fexppeuk3m/</link>
      <pubDate>Fri, 04 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://alili.tech/archive/fexppeuk3m/</guid>
      <description>什么是数学归纳法？ 在棋盘上放麦粒的规则是，第一格放一粒，第二格放两粒，以此类推，每一小格内都比前一小格多一倍的麦子，直至放满 64 个格子。你发现第 1 格到第 8 格的麦子数分别是：1、2、4、8、16、32、64、128。
找规律 对于类似这种无穷数列的问题，我们通常可以采用数学归纳法（Mathematical Induction）来证明
数学归纳法步骤  证明基本情况（通常是 n=1 的时候）是否成立； 假设 n=k−1 成立，再证明 n=k 也是成立的（k 为任意大于 1 的自然数）。  和使用迭代法的计算相比，数学归纳法最大的特点就在于“归纳”二字。它已经总结出了规律。只要我们能够证明这个规律是正确的，就没有必要进行逐步的推算，可以节省很多时间和资源。
代码示例 let grid = 63; console.time(&#39;归纳法耗时&#39;) console.log(`舍罕王给了这么多粒: ${ Math.pow(2, grid) - 1 }`) console.timeEnd(&#39;归纳法耗时&#39;)   递归调用的代码和数学归纳法的逻辑是一致的,但是数学归纳法实现的运行时间几乎为 0
 数学归纳法需要我们能做出合理的命题假设，然后才能进行证明。</description>
    </item>
    
    <item>
      <title>数学篇 - 迭代法,让每次计算都更接近真像(笔记)</title>
      <link>https://alili.tech/archive/35dkyj5swxr/</link>
      <pubDate>Thu, 03 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://alili.tech/archive/35dkyj5swxr/</guid>
      <description>什么是迭代法（Iterative Method）？ 就是不断地用旧的变量值，递推计算新的变量值。
小故事:  古印度国王舍罕酷爱下棋，他打算重赏国际象棋的发明人宰相西萨·班·达依尔。这位聪明的大臣指着象棋盘对国王说：“陛下，我不要别的赏赐，请您在这张棋盘的第一个小格内放入一粒麦子，在第二个小格内放入两粒，第三小格内放入给四粒，以此类推，每一小格内都比前一小格加一倍的麦子，直至放满 64 个格子，然后将棋盘上所有的麦粒都赏给您的仆人我吧！”国王自以为小事一桩，痛快地答应了。可是，当开始放麦粒之后，国王发现，还没放到第二十格，一袋麦子已经空了。随着，一袋又一袋的麦子被放入棋盘的格子里，国王很快看出来，即便拿来全印度的粮食，也兑现不了对达依尔的诺言。
 通过一个函数来计算最后麦子的数量. 用计算机语言其实特别适合 function getNumberOfWheat(grid){ numberOfWheatInGrid = 0; // 当前格子里麦粒的数量 let numberOfWheatInGrid = 1; // 第一个格子里麦粒的数量 // 先放一粒米 sum += numberOfWheatInGrid; for (let i = 2; i &amp;lt;= grid; i ++) { numberOfWheatInGrid *= 2; // 当前格子里麦粒的数量是前一格的2倍 sum += numberOfWheatInGrid; // 累计麦粒总数 } return sum; } // 计算64格的数量 console.log(getNumberOfWheat(64))  具体应用？  求数值的精确或者近似解。典型的方法包括二分法（Bisection method）和牛顿迭代法（Newton’s method）。
 在一定范围内查找目标值。典型的方法包括二分查找。
 机器学习算法中的迭代。相关的算法或者模型有很多，比如 K- 均值算法（K-means clustering）、PageRank 的马尔科夫链（Markov chain）、梯度下降法（Gradient descent）等等。迭代法之所以在机器学习中有广泛的应用，是因为很多时候机器学习的过程，就是根据已知的数据和一定的假设，求一个局部最优解。而迭代法可以帮助学习算法逐步搜索，直至发现这种解。</description>
    </item>
    
    <item>
      <title>数学篇 - 余数与哈希函数(笔记)</title>
      <link>https://alili.tech/archive/jvh7xaof84/</link>
      <pubDate>Wed, 02 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://alili.tech/archive/jvh7xaof84/</guid>
      <description>余数 例1: 今天是星期三，你想知道 50 天之后是星期几，那你可以这样算，拿 50 除以 7（因为一个星期有 7 天），然后余 1，最后在今天的基础上加一天，这样你就能知道 50 天之后是星期四了
例2: 如果你要展示 1123 条数据，每页 10 条，那该怎么计算总共的页数呢？我想你肯定是拿 1123 除以 10，最后得到商是 112，余数是 3，所以你的总页数就是 112+1=113，而最后的余数就是多出来，凑不够一页的数据。
 余数总是在一个固定的范围内
 同余定理 数学上，两个整数除以同一个整数，若得相同余数，则二整数同余
如何理解 100 天里，所有星期一的这些天都是同余的，所有星期二的这些天就是同余的，同理，星期三、星期四等等这些天也都是同余的
哈希 Hash 将任意长度的输入，通过哈希算法，压缩为某一固定长度的输出
想想星期的概念: 将数据取余  ps. size指的是有限空间的数目而不是大小
 在这个公式中，x 表示等待被转换的数值，而 size 表示有限存储空间的数目，mod 表示取余操作。通过余数，你就能将任何数值，转换为有限范围内的一个数值，然后根据这个新的数值，来确定将数据存放在何处。
假设有两条记录，它们的记录标号分别是 1 和 101。我们把这些模 100 之后余数都是 1 的，存放到第 1 个可用空间里。以此类推，将余数为 2 的 2、102、202 等，存放到第 2 个可用空间，将 100、200、300 等存放到第 100 个可用空间里。
再复杂一点 我们假设随机数 MAX 是 590199，那么我们针对标号为 1 的记录进行重新计算，最后的计算结果就是 0，而针对标号 101 的记录，如果随机数 MAX 取 627901，对应的结果应该是 2。这样先前被分配到空间 1 的两条记录，在新的计算公式作用下，就会被分配到不同的可用空间中。</description>
    </item>
    
    <item>
      <title>数学篇 - 计算机的源头二进制(笔记)</title>
      <link>https://alili.tech/archive/ja86xk20l2/</link>
      <pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://alili.tech/archive/ja86xk20l2/</guid>
      <description>计算机起源  计算机的起源是数学中的二进制计数法  什么是二进制计数法？ 日常的十进制 阿拉伯数字由从 0 到 9 这样 10 个计数符号组成，并采取进位制法,每10进一位,2871为例
其中 ^ 表示幂或次方运算。十进制的数位（千位、百位、十位等）全部都是 10^n 的形式。需要特别注意的是，任何非 0 数字的 0 次方均为 1。在这个新的表示式里，10 被称为十进制计数法的基数.
二进制 我们将基数改为2,就可以理解二进制的展示了.例如110101.
 二进制的数位就是 2^n 的形式
 其他进制 我们只要基于基数的改动,就可以使用任一进制来展示我们的数字.
JavaScript 进制转换 parseInt(num,8); //八进制转十进制 parseInt(num,16); //十六进制转十进制 parseInt(num).toString(8) //十进制转八进制 parseInt(num).toString(16) //十进制转十六进制 parseInt(num,2).toString(8) //二进制转八进制 parseInt(num,2).toString(16) //二进制转十六进制 parseInt(num,8).toString(2) //八进制转二进制 parseInt(num,8).toString(16) //八进制转十六进制 parseInt(num,16).toString(2) //十六进制转二进制 parseInt(num,16).toString(8) //十六进制转八进制  计算机为什么使用二进制？ 组成计算机系统的逻辑电路通常只有两个状态，即开关的接通与断开。
二进制的位操作 向左移位 二进制 110101 向左移一位，就是在末尾添加一位 0，因此 110101 就变成了 1101010
如果将 1101010 换算为十进制，就是 106，你有没有发现，106 正好是 53 的 2 倍 &amp;gt; 二进制左移一位，其实就是将数字翻倍。</description>
    </item>
    
  </channel>
</rss>